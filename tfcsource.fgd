//-------------------------------------------------------------------------
//
// Game data for Team Fortress Classic Source.
//
//-------------------------------------------------------------------------

@include "base.fgd"

@BaseClass base(Targetname, Origin, Global, prop_static_base) = BaseVehicle
[
	vehiclescript(string) : "Vehicle Script File" : "scripts/vehicles/jeep_test.txt"
	actionScale(float) : "Scale of action input / framerate" : "1"

	// Inputs
	input Action(float) : "Set the speed of the action animation"

	input TurnOn(void) : "Turn on: Start engine & enable throttle"
	input TurnOff(void) : "Turn off: Stop engine, disable throttle, engage brakes."

	input Lock(void) : "Prevent the player from entering or exiting the vehicle."
	input Unlock(void) : "Re-allow the player to enter or exit the vehicle."
]


@BaseClass base(BaseVehicle) = BaseDriveableVehicle
[
	VehicleLocked(choices) : "Start locked" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]	

	// Outputs
	output PlayerOn(void) : "Player entered the vehicle"
	output PlayerOff(void) : "Player exited the vehicle"
	
	output PressedAttack(void) : "Player Pressed attack key"
	output PressedAttack2(void) : "Player Pressed attack2 key"

	output AttackAxis(string) : "State of attack button [0,1]"
	output Attack2Axis(string) : "State of attack2 button [0,1]"
	
	// Inputs
	input HandBrakeOn(void) : "Turns the handbrake on"
	input HandBrakeOff(void): "Releases the handbrake"
]

@SolidClass = func_ladder : 
	"Ladder. Players will be able to freely along this brush, as if it was a ladder. If you are using a model prop " +
	"for the visual representation of the ladder in the map, apply the toolsinvisibleladder material to the " +
	"func_ladder brush."
[
]

@PointClass base(PlayerClass, Angles) studio("models/editor/playerstart.mdl") = info_player_deathmatch :
	"This entity indicates the position and facing direction at which the player will spawn during a deathmatch map. Any number of "+
	"info_player_deathmatch entities may be placed in a map."
[
]


@PointClass base(PlayerClass, Angles) studio("models/editor/playerstart.mdl") = info_player_red :
	"This entity indicates the position and facing direction at which the player will spawn a red member. Any number of "+
	"info_player_red entities may be placed in a map."
[
]


@PointClass base(PlayerClass, Angles) studio("models/editor/playerstart.mdl") = info_player_blue :
	"This entity indicates the position and facing direction at which the player will spawn a blue member. Any number of "+
	"info_player_red entities may be placed in a map."
[
]

@PointClass base(PlayerClass, Angles) studio("models/editor/playerstart.mdl") = info_player_yellow :
	"This entity indicates the position and facing direction at which the player will spawn a yellow member. Any number of "+
	"info_player_yellow entities may be placed in a map."
[
]


@PointClass base(PlayerClass, Angles) studio("models/editor/playerstart.mdl") = info_player_green :
	"This entity indicates the position and facing direction at which the player will spawn a green member. Any number of "+
	"info_player_green entities may be placed in a map."
[
]

@FilterClass base(BaseFilter) size(-8 -8 -8, 8 8 8) = filter_activator_team :
	"A filter that filters by the team of the activator."
[
	filterteam(choices) : "Filter Team Number" : 2 : 
		"The team number to filter by. If the filter mode is Allow, only entities whose "+
		"team number matches the given team will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose team number matches the given team will pass the filter." =
	[
		2 : "Red"
		3 : "Blue"
		4 : "Yellow"
		5 : "Green"
	]
]

@PointClass base(Angles) studio() = entity_backpack : "An Perfect Dark weapon spawn point"
[
	model(studio) : "Item Model" : "models/items/backpack.mdl"

	Cells(integer)		: "ammo_cells" : 50   : "How many cells to give to the player?"
	Nails(integer)		: "ammo_nails" : 50   : "How many nails to give to the player?"
	Shells(integer)		: "ammo_shells" : 50   : "How many shells to give to the player?"
	Explosives(integer)	: "ammo_explosives" : 20   : "How many explosives to give to the player?"

	Shouldwespawn(choices) : "Should We Respawn?" : 4 : 
		"Should we respawn after picked up? If NO then after picked up removed forever. "+
		"If YES then after some time passes we respawn unto the world." =
	[
		4 : "NO"
		3 : "YES"
	]
	
	
	
]

@PointClass base(prop_physics) studioprop() sphere(fademindist) sphere(fademaxdist) = prop_physics_respawnable :
	"This class is the same as prop_physics, except it respawns after it breaks"
[
	RespawnTime(float) : "Respawn Time" : 60 : "Amount in seconds this prop will respawn after it breaks."
]

@PointClass base(BaseVehicle) studioprop() = prop_vehicle :
	"Studiomodel vehicle that can be driven via inputs."
[
	// Inputs
	input Steer(float) : "Steer the vehicle +/-1"
	input Throttle(float) : "Throttle +/-1"

	spawnflags(flags) =
	[
		1 : "Always Think (Run physics every frame)" : 0
	]
]


@PointClass base(BaseDriveableVehicle) studioprop() = prop_vehicle_driveable :
	"Generic driveable studiomodel vehicle."
[
]